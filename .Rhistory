mu1<-0
mu2<-0
sigma1<-1
sigma2<-1
s1<- sqrt(1-rho^2)*sigma1
s2<- sqrt(1-rho^2)*sigma2
X<-matrix(0,N,2)
X[1,]<-c(a,b)
for (i in 2:N) {
x2<-X[i-1,2]
m1<-mu1+rho*(x2 - mu2) * sigma1/sigma2
X[i, 1] <- rnorm(1, m1, s1)
x1 <- X[i, 1]
m2 <- mu2 + rho * (x1 - mu1) * sigma2/sigma1
X[i, 2] <- rnorm(1, m2, s2)
}
x<-X
#show several statistic of the samples,and plot the distribution
colMeans(x)
cov(x)
cor(x)
x
}
apply_data<-function(data,label,n,b){
psi <- t(apply(data, 1, cumsum))
print(colnames(psi))
print(nrow(psi))
print(ncol(psi))
for (i in 1:nrow(psi))
psi[i,] <- psi[i,] / (1:ncol(psi))
print(Gelman.Rubin(psi))
#plot psi for the three chains
par(mfrow=c(2,2),pin=c(1,0.6))
for (i in 1:3)
plot(psi[i, (b+1):n], type="l",
xlab=i, ylab=bquote(psi))
par(mfrow=c(1,1)) #restore default
#plot the sequence of R-hat statistics
rhat <- rep(0, n)
for (j in (b+1):n)
rhat[j] <- Gelman.Rubin(psi[,1:j])
plot(rhat[b+1:n], type="l", xlab="", ylab="R",main=paste(label,"n:",n,"b:",b))
abline(h=1.2, lty=2)
}
plot_R<-function(n,b){
k <- 3 #number of chains to generate
n <- n #length of chains
b <- b #burn-in length
#choose overdispersed initial values
x_list<-matrix(c(0,0,1,1,2,2),3,2,byrow = TRUE)
#generate the chains
X <- matrix(0, nrow=k, ncol=n)
Y <- matrix(0, nrow=k, ncol=n)
for (i in 1:k){
data<-gr_chain(x_list[i,1],x_list[i,2],n,b)
X[i, ] <- data[,1]
Y[i, ] <- data[,2]
}
apply_data(X,"X",n,b)
apply_data(Y,"Y",n,b)
}
#
plot_R(25000,1000)
rm(list = ls())
devtools::build_vignettes()
SGD_min <- function(x,alpha,N,coefficient,powers) {
get_G <- function(x,coefficient,powers) {
gradient<-0
for (i in 1:length(coefficient)) {
gradient<-gradient+coefficient[i]*powers[i]*x^(powers[i]-1)
}
print(gradient)
return (gradient)
}
for (i in 1:N) {
if (! is.na(x)){
x<-x-alpha*get_G(x,coefficient,powers)
}
else{
x<-stats::rnorm(1,0,100)
}
}
print("The minimum function value is")
y<-0
for (i in 1:length(coefficient)) {
y<-y+coefficient[i]*x^powers[i]
}
print(y)
#plot the curve
exp_par <- function(x) {
y<-0
len_par<-length(coefficient)
for (i in 1:len_par) {
y<-y+coefficient[i]*x^powers[i]
}
return (y)
}
graphics::curve(exp_par,-20,20)
return(x)
}
Arima_forecast <- function(path,start,end,h) {
#Implementing time series forecasting using Auto ARIMA method
# Dataset contains Californa_Wine_Production from 1980 to 2020
# library(readxl)
data<-readxl::read_excel(path)
# data(data)
data<-data['Production']
utils::str(data)
#We do not divide into test and train data.Hence not computing Error  metrics
#This code just shows the implementation of Auto arima in R
#Converting data to time series
# library(stats)
data_ts=stats::ts(data, frequency = 1, start = start,end = end)
data_ts
#Plotting time series
graphics::par(mfrow=c(1,1))
plot(data_ts)
#ACF and PACF of data
graphics::par(mfrow=c(1,3))
stats::plot.ts(data_ts)
stats::acf(data_ts, lag.max=10)
stats::pacf(data_ts, lag.max=10)
# Build time series model using auto.arima
# library(forecast)
model_autoarima= forecast::auto.arima(data_ts,ic='aic')
model_autoarima
#Forecasting using auto arima model
data_forecasts=forecast::forecast(model_autoarima,h=h)
par(mfrow=c(1,1))
plot(data_forecasts)
data_forecasts
}
library(Rcpp)
cppFunction(code='
int maxPoints(NumericMatrix points) {
int len = points.nrow();
// when the number of points is not enough
if(len < 3) {
return len;
}
int maxNum = 2;
NumericVector maxrecord;
// Traverse every two points
for(double i = 0; i < len - 1; i ++) {
for(double j = i + 1; j < len; j ++) {
// count the Number of equal slopes.
NumericVector record ={i,j};
int count = 2;
double dx = points(i,0) - points(j,0);
double dy = points(i,1) - points(j,1);
// Compare with other points
for(int k = j + 1; k < len; k ++) {
// If the slopes are equal
if(dx * (points(i,1) - points(k,1)) == dy * (points(i,0) - points(k,0))) {
count ++;
record.push_back(k);
}
}
maxrecord=(maxNum>=count)?maxrecord:record;
maxNum = (maxNum>=count)? maxNum: count;
if(maxNum > len / 2) return maxNum;
}
}
// Rprintf("the maxrecord is: ",maxrecord);
return maxNum;
}
')
if None
if (None) {print(1)}
if ("") {print(1)}
library(Rcpp)
cppFunction(code='
int maxPoints(NumericMatrix points) {
int len = points.nrow();
// when the number of points is not enough
if(len < 3) {
return len;
}
int maxNum = 2;
NumericVector maxrecord;
// Traverse every two points
for(double i = 0; i < len - 1; i ++) {
for(double j = i + 1; j < len; j ++) {
// count the Number of equal slopes.
NumericVector record ={i,j};
int count = 2;
double dx = points(i,0) - points(j,0);
double dy = points(i,1) - points(j,1);
// Compare with other points
for(int k = j + 1; k < len; k ++) {
// If the slopes are equal
if(dx * (points(i,1) - points(k,1)) == dy * (points(i,0) - points(k,0))) {
count ++;
record.push_back(k);
}
}
maxrecord=(maxNum>=count)?maxrecord:record;
maxNum = (maxNum>=count)? maxNum: count;
if(maxNum > len / 2) return maxNum;
}
}
// Rprintf("the maxrecord is: ",maxrecord);
return maxNum;
}
')
if (0) {print(1)}
}
if (0) {print(1)}
if (!0) {print(1)}
#SGD_min
x<-stats::rnorm(1,0,100);N<-2000
alpha<-0.005;coefficient<-c(1,3);powers<-c(2,4)
x_last<-SGD_min(x,alpha,N,coefficient,powers)
paste("The x corresponding to the function value is",x_last)
#Arima_forecast
path<-"D:\\Code\\R_HW\\Californa_Wine_Production.xlsx"
start <- 1980
end <- 2020
h<-36
Arima_forecast(start,end,h,path)
Arima_forecast <- function(start,end,h,path=0) {
#Implementing time series forecasting using Auto ARIMA method
# Dataset contains Californa_Wine_Production from 1980 to 2020
# library(readxl)
data<-readxl::read_excel(path)
# data(data)
data<-data['Production']
utils::str(data)
#We do not divide into test and train data.Hence not computing Error  metrics
#This code just shows the implementation of Auto arima in R
#Converting data to time series
# library(stats)
data_ts=stats::ts(data, frequency = 1, start = start,end = end)
data_ts
#Plotting time series
graphics::par(mfrow=c(1,1))
plot(data_ts)
#ACF and PACF of data
graphics::par(mfrow=c(1,3))
stats::plot.ts(data_ts)
stats::acf(data_ts, lag.max=10)
stats::pacf(data_ts, lag.max=10)
# Build time series model using auto.arima
# library(forecast)
model_autoarima= forecast::auto.arima(data_ts,ic='aic')
model_autoarima
#Forecasting using auto arima model
data_forecasts=forecast::forecast(model_autoarima,h=h)
par(mfrow=c(1,1))
plot(data_forecasts)
data_forecasts
}
#SGD_min
x<-stats::rnorm(1,0,100);N<-2000
alpha<-0.005;coefficient<-c(1,3);powers<-c(2,4)
x_last<-SGD_min(x,alpha,N,coefficient,powers)
paste("The x corresponding to the function value is",x_last)
#Arima_forecast
path<-"D:\\Code\\R_HW\\Californa_Wine_Production.xlsx"
start <- 1980
end <- 2020
h<-36
Arima_forecast(start,end,h,path)
#maxPoints
points<-matrix(c(1,1,2,2,3,3),3,2,byrow = TRUE)
maxPoints(points)
library(readxl)
path<-"D:\\Code\\R_HW\\Californa_Wine_Production.xlsx"
data<-readxl::read_excel(path)
View(data)
usethis::use_data(data)
Arima_forecast <- function(start,end,h,path=0) {
#Implementing time series forecasting using Auto ARIMA method
# Dataset contains Californa_Wine_Production from 1980 to 2020
# library(readxl)
if (path) {
data<-readxl::read_excel(path)
}
else{
data(data)
}
data<-data['Production']
utils::str(data)
#We do not divide into test and train data.Hence not computing Error  metrics
#This code just shows the implementation of Auto arima in R
#Converting data to time series
# library(stats)
data_ts=stats::ts(data, frequency = 1, start = start,end = end)
data_ts
#Plotting time series
graphics::par(mfrow=c(1,1))
plot(data_ts)
#ACF and PACF of data
graphics::par(mfrow=c(1,3))
stats::plot.ts(data_ts)
stats::acf(data_ts, lag.max=10)
stats::pacf(data_ts, lag.max=10)
# Build time series model using auto.arima
# library(forecast)
model_autoarima= forecast::auto.arima(data_ts,ic='aic')
model_autoarima
#Forecasting using auto arima model
data_forecasts=forecast::forecast(model_autoarima,h=h)
par(mfrow=c(1,1))
plot(data_forecasts)
data_forecasts
}
#SGD_min
x<-stats::rnorm(1,0,100);N<-2000
alpha<-0.005;coefficient<-c(1,3);powers<-c(2,4)
x_last<-SGD_min(x,alpha,N,coefficient,powers)
paste("The x corresponding to the function value is",x_last)
#Arima_forecast
# path<-"D:\\Code\\R_HW\\Californa_Wine_Production.xlsx"
start <- 1980
end <- 2020
h<-36
Arima_forecast(start,end,h)
#maxPoints
points<-matrix(c(1,1,2,2,3,3),3,2,byrow = TRUE)
maxPoints(points)
Arima_forecast <- function(start,end,h,path=0) {
#Implementing time series forecasting using Auto ARIMA method
# Dataset contains Californa_Wine_Production from 1980 to 2020
# library(readxl)
if (path) {
data<-readxl::read_excel(path)
}
else{
data<-data(data)
}
data<-data['Production']
utils::str(data)
#We do not divide into test and train data.Hence not computing Error  metrics
#This code just shows the implementation of Auto arima in R
#Converting data to time series
# library(stats)
data_ts=stats::ts(data, frequency = 1, start = start,end = end)
data_ts
#Plotting time series
graphics::par(mfrow=c(1,1))
plot(data_ts)
#ACF and PACF of data
graphics::par(mfrow=c(1,3))
stats::plot.ts(data_ts)
stats::acf(data_ts, lag.max=10)
stats::pacf(data_ts, lag.max=10)
# Build time series model using auto.arima
# library(forecast)
model_autoarima= forecast::auto.arima(data_ts,ic='aic')
model_autoarima
#Forecasting using auto arima model
data_forecasts=forecast::forecast(model_autoarima,h=h)
par(mfrow=c(1,1))
plot(data_forecasts)
data_forecasts
}
#SGD_min
x<-stats::rnorm(1,0,100);N<-2000
alpha<-0.005;coefficient<-c(1,3);powers<-c(2,4)
x_last<-SGD_min(x,alpha,N,coefficient,powers)
paste("The x corresponding to the function value is",x_last)
#Arima_forecast
# path<-"D:\\Code\\R_HW\\Californa_Wine_Production.xlsx"
start <- 1980
end <- 2020
h<-36
Arima_forecast(start,end,h)
Arima_forecast <- function(start,end,h,path=0) {
#Implementing time series forecasting using Auto ARIMA method
# Dataset contains Californa_Wine_Production from 1980 to 2020
# library(readxl)
if (path) {
data<-readxl::read_excel(path)
}
else{
data(data)
}
data<-data['Production']
utils::str(data)
#We do not divide into test and train data.Hence not computing Error  metrics
#This code just shows the implementation of Auto arima in R
#Converting data to time series
# library(stats)
data_ts=stats::ts(data, frequency = 1, start = start,end = end)
data_ts
#Plotting time series
graphics::par(mfrow=c(1,1))
plot(data_ts)
#ACF and PACF of data
graphics::par(mfrow=c(1,3))
stats::plot.ts(data_ts)
stats::acf(data_ts, lag.max=10)
stats::pacf(data_ts, lag.max=10)
# Build time series model using auto.arima
# library(forecast)
model_autoarima= forecast::auto.arima(data_ts,ic='aic')
model_autoarima
#Forecasting using auto arima model
data_forecasts=forecast::forecast(model_autoarima,h=h)
par(mfrow=c(1,1))
plot(data_forecasts)
data_forecasts
}
#SGD_min
x<-stats::rnorm(1,0,100);N<-2000
alpha<-0.005;coefficient<-c(1,3);powers<-c(2,4)
x_last<-SGD_min(x,alpha,N,coefficient,powers)
paste("The x corresponding to the function value is",x_last)
#Arima_forecast
# path<-"D:\\Code\\R_HW\\Californa_Wine_Production.xlsx"
start <- 1980
end <- 2020
h<-36
Arima_forecast(start,end,h)
#maxPoints
points<-matrix(c(1,1,2,2,3,3),3,2,byrow = TRUE)
maxPoints(points)
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build(vignettes=FALSE)
install.packages('../StatComp22032_1.0.tar.gz',repo=NULL)
devtools::install_github("1183038359/StatComp22032",build_vignettes = TRUE, force=T)
devtools::install_github("1183038359/StatComp22032",build_vignettes = TRUE, force=T)
install.packages("rlang")
devtools::install_github("1183038359/StatComp22032",build_vignettes = TRUE, force=T)
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
remove. packages('rlang')
remove.packages('rlang')
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
devtools::install_github("1183038359/StatComp22032",build_vignettes = TRUE, force=T)
devtools::install_github("1183038359/StatComp22032",build_vignettes = TRUE, force=T)
devtools::build(vignettes=FALSE)
install.packages('../StatComp22032_1.0.tar.gz',repo=NULL)
library(StatComp22032)
?vctrs
??vctrs
library(vctrs)
install.packages("vctrs")
library(StatComp22032)
library(vctrs)
library(StatComp22032)
install.packages("vctrs")
install.packages("vctrs")
install.packages("vctrs")
library(StatComp22032)
points<-matrix(c(1,1,2,2,3,3),3,2,byrow = TRUE)
maxPoints(points)
devtools::document()
devtools::build(vignettes=FALSE)
install.packages('../StatComp22032_1.0.tar.gz',repo=NULL)
install.packages('../StatComp22032_1.0.tar.gz',repo=NULL)
library(StatComp22032)
points<-matrix(c(1,1,2,2,3,3),3,2,byrow = TRUE)
maxPoints(points)
devtools::document()
devtools::build(vignettes=FALSE)
install.packages('../StatComp22032_1.0.tar.gz',repo=NULL)
library(StatComp22032)
points<-matrix(c(1,1,2,2,3,3),3,2,byrow = TRUE)
maxPoints(points)
x<-stats::rnorm(1,0,100);N<-2000
alpha<-0.005;coefficient<-c(1,3);powers<-c(2,4)
x_last<-SGD_min(x,alpha,N,coefficient,powers)
path<-"D:\\Code\\R_HW\\Californa_Wine_Production.xlsx"
start <- 1980
end <- 2020
h<-36
Arima_forecast(path,start,end,h)
devtools::install_github("1183038359/StatComp22032",build_vignettes = TRUE, force=T)
library(Rcpp)
library(StatComp22032)
x<-stats::rnorm(1,0,100);N<-2000
alpha<-0.005;coefficient<-c(1,3);powers<-c(2,4)
x_last<-SGD_min(x,alpha,N,coefficient,powers)
paste("The x corresponding to the function value is",x_last)
points<-matrix(c(1,1,2,2,3,3),3,2,byrow = TRUE)
maxPoints(points)
path<-"D:\\Code\\R_HW\\Californa_Wine_Production.xlsx"
start <- 1980
end <- 2020
h<-36
Arima_forecast(path,start,end,h)
path<-"D:\\Code\\Californa_Wine_Production.xlsx"
start <- 1980
end <- 2020
h<-36
Arima_forecast(path,start,end,h)
start <- 1980
end <- 2020
h<-36
Arima_forecast(path,start,end,h)
start <- 1980
end <- 2020
h<-36
Arima_forecast(start,end,h)
start <- 1980
end <- 2020
h<-36
Arima_forecast(start,end,h,path)
devtools::install_github("tongbowen1999/StatComp22095",build_vignettes = TRUE, force=T)
?Arima_forecast
?StatComp22095
devtools::document()
devtools::document()
devtools::build(vignettes=FALSE)
install.packages('../StatComp22032_1.0.tar.gz',repo=NULL)
